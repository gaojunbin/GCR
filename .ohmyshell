# =========How to use=============
# for bash
# >> echo 'source ~/.ohmyshell' >> ~/.bashrc
# for zsh
# >> echo 'source ~/.ohmyshell' >> ~/.zshrc
# =========Outline================
# --- myupdate - support update GCR Toolkit from GitHub Repo.
# |
# --- mytool - Some basic tools for common using.
# |
# --- mypip - pip tools.
# |
# --- myenv - Anaconda tools.
# |
# --- mygpu - useful functions for GPU and cuda.
# |
# --- mypermission - some functions for permission, passward, etc.
# |
# --- mygit - Git tools.
# |
# --- Others
# ========Outline end============

# lazy load
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

source ~/.ohmyprint

# shell type [~/.bashrc or ~/.zshrc]
# support tabby shell working directory reporting
if [[ "$SHELL" == *"zsh" ]];then
    declare -A manual_ohmyshell=(
        ["myupdate"]="support update GCR Toolkit from GitHub Repo."
        ["mytool"]="Some basic tools for common using."
        ["mypip"]="pip tools."
        ["myenv"]="Anaconda tools."
        ["mygpu"]="useful functions for GPU and cuda."
        ["mypermission"]="some functions for permission, passward, etc."
        ["mygit"]="Git tools"
    )
    shell_file=~/.zshrc
    precmd () { echo -n "\x1b]1337;CurrentDir=$(pwd)\x07" }
elif [[ "$SHELL" == *"bash" ]];then
    shell_file=~/.bashrc
    export PS1="$PS1\[\e]1337;CurrentDir="'$(pwd)\a\]'
else
    print_error "Invalid shell type: $SHELL"
fi

# 1. check update
# GCR update time lock
GCR_update_file=$HOME/.gcr.update.lock
GCR_plugin_update_file=$HOME/.gcr.plugin.update.lock

show_update_info(){
    printf "\n"
    printf "  "
    print_text "yellow" "●" "false"
    printf " "
    print_text "white" "Recent Updates" "false"
    printf "\n"

    # Get updates with minimal formatting
    local updates=$(curl -s https://raw.githubusercontent.com/gaojunbin/GCR/master/recent_updates 2>/dev/null)
    if [ -n "$updates" ]; then
        echo "$updates" | while IFS= read -r line; do
            if [ -n "$line" ]; then
                printf "     %s\n" "$line"
            fi
        done
    fi
    printf "\n"
}

gcr_need_update(){
    if [ "$(uname -s)" = Darwin ];then
        remote_ohmyshell_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyshell | md5)
        remote_ohmytool_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmytool | md5)
        remote_ohmyzsh_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyzsh | md5)
        remote_p9k_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.p9k.zsh | md5)
        remote_vimrc_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.vimrc | md5)
        remote_ohmyprint_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyprint | md5)

        local_ohmyshell_MD5=$(md5 -q ~/.ohmyshell)
        local_ohmytool_MD5=$(md5 -q ~/.ohmytool)
        local_ohmyzsh_MD5=$(md5 -q ~/.ohmyzsh)
        local_p9k_MD5=$(md5 -q ~/.p9k.zsh)
        local_vimrc_MD5=$(md5 -q ~/.vimrc)
        local_ohmyprint_MD5=$(md5 -q ~/.ohmyprint)

    elif [ "$(uname -s)" = Linux ];then
        remote_ohmyshell_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyshell | md5sum | awk '{print $1}')
        remote_ohmytool_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmytool | md5sum | awk '{print $1}')
        remote_ohmyzsh_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyzsh | md5sum | awk '{print $1}')
        remote_p9k_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.p9k.zsh | md5sum | awk '{print $1}')
        remote_vimrc_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.vimrc | md5sum | awk '{print $1}')
        remote_ohmyprint_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyprint | md5sum | awk '{print $1}')

        local_ohmyshell_MD5=$(md5sum ~/.ohmyshell | awk '{print $1}')
        local_ohmytool_MD5=$(md5sum ~/.ohmytool | awk '{print $1}')
        local_ohmyzsh_MD5=$(md5sum ~/.ohmyzsh | awk '{print $1}')
        local_p9k_MD5=$(md5sum ~/.p9k.zsh | awk '{print $1}')
        local_vimrc_MD5=$(md5sum ~/.vimrc | awk '{print $1}')
        local_ohmyprint_MD5=$(md5sum ~/.ohmyprint | awk '{print $1}')
    fi
        
    if [ "${remote_ohmyshell_MD5}" != "${local_ohmyshell_MD5}" ] || \
       [ "${remote_ohmytool_MD5}" != "${local_ohmytool_MD5}" ] || \
       [ "${remote_ohmyzsh_MD5}" != "${local_ohmyzsh_MD5}" ] || \
       [ "${remote_p9k_MD5}" != "${local_p9k_MD5}" ] || \
       [ "${remote_vimrc_MD5}" != "${local_vimrc_MD5}" ] || \
       [ "${remote_ohmyprint_MD5}" != "${local_ohmyprint_MD5}" ]; then
        
        return 0
    else
        return 1
    fi
}

# support update GCR Toolkit from GitHub Repo
myupdate(){
    print_table_text "Updating GCR ..." "true" "yellow" "red" $(tput cols)
    curl -o ~/.ohmyshell https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyshell
    curl -o ~/.ohmytool https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmytool 
    curl -o ~/.ohmyzsh https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyzsh
    curl -o ~/.p9k.zsh https://raw.githubusercontent.com/gaojunbin/GCR/master/.p9k.zsh
    curl -o ~/.vimrc https://raw.githubusercontent.com/gaojunbin/GCR/master/.vimrc
    curl -o ~/.ohmyprint https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyprint
    date +%s > $GCR_update_file
    print_table_text "Success!" "false" "yellow" "red" $(tput cols)
    show_update_info
    source ${shell_file}
}

myupdateplug(){
    # update_joshuto
    # update_PBShelper
    # update_tssh
    # update_safe_rm
    # date +%s > $GCR_plugin_update_file
    # source ${shell_file}
}

find_gcr_update(){
    if gcr_need_update; then
        # only auto update when AUTO_GCR_UPDATE is explicitly set to true
        if [ "${AUTO_GCR_UPDATE}" = "true" ]; then
            myupdate
        else
            show_update_info
            printf "  "
            print_text "cyan" "→" "false"
            printf " "
            print_text "white" "Run " "false"
            print_text "green" "myupdate" "false"
            print_text "white" " to upgrade" "false"
            printf "\n\n"
            date +%s > $GCR_update_file
        fi
    fi
}

# if CHECK_GCR_UPDATE is not false, check update every login
if [ "${CHECK_GCR_UPDATE:-}" != "false" ]; then
    find_gcr_update
fi

# ==================Auto Check Update per day (GCR & GCR plugin)==================
if [ -f "$GCR_update_file" ]; then
    last_timestamp=$(cat $GCR_update_file)
    current_timestamp=$(date +%s)

    if [[ "$last_timestamp" =~ ^[0-9]+$ ]]; then
        diff=$((current_timestamp - last_timestamp))
        # 1 days (86400s)
        if [ $diff -ge 86400 ]; then
            find_gcr_update
        fi
    else
        find_gcr_update
    fi
else
    find_gcr_update
fi

if [ -f "$GCR_plugin_update_file" ]; then
    last_timestamp=$(cat $GCR_plugin_update_file)
    current_timestamp=$(date +%s)

    if [[ "$last_timestamp" =~ ^[0-9]+$ ]]; then
        diff=$((current_timestamp - last_timestamp))
        # 1 days (86400s)
        if [ $diff -ge 86400 ]; then
            myupdateplug
        fi
    else
        myupdateplug
    fi
else
    myupdateplug
fi

# 2.show GCR info
# show document info
printf "  "
print_text "cyan" "→" "false"
printf " "
print_text "white" "Documentation: " "false"
print_text "cyan" "https://gcr.junbingao.com" "false"
printf "\n\n"

show_GCR_info(){
    star_line=""
    for ((i = 0; i < $(tput cols); i++)); do
            star_line+="*"
    done
    print_text "green" $star_line "true"
    printf "\n"
    printf "\n"
    print_text "yellow" "Welcome to GCR Toolkit!" "false" $(tput cols)
    printf "\n"
    printf "\n"
    print_text "green" $star_line "true"
    printf "\n"
    printf "\n"
    print_line "cyan" $(tput cols)
    print_text "cyan" "Basic Info:" "false"
    printf "\n"
    printf "\t"
    print_text "blue" "Author: " "false"
    print_text "white" "Junbin Gao" "false"
    printf "\n"
    printf "\t"
    print_text "blue" "Github: " "false"
    print_text "white" "https://github.com/gaojunbin/GCR" "false"
    printf "\n"
    printf "\t"
    print_text "blue" "Intro : " "false"
    print_text "white" "GCR is a shell plugin that makes it easier and more elegant to use the command line on a unix operating system without having to memorize cumbersome, retarded commands." "false"
    printf "\n"
    print_line "cyan" $(tput cols)
    if [[ "$SHELL" == *"zsh" ]];then
        for k in "${(@k)manual_ohmyshell}"; do
            print_text "cyan" "Manual:" "false"
            printf "\n"
            printf "\t"
            print_text "blue" "ohmyshell: " "false"
            print_text "white" "Some basic command in shell. Type " "false"
            print_text "green" "$ ohmyshell " "false"
            print_text "white" "see all the available functions. " "false"
            printf "\n"
            printf "\t\t"
            print_text "green" "$k: " "false"
            print_text "white" "${manual_ohmyshell[$k]}" "false"
            printf "\n"

            printf "\n"
            printf "\t"
            print_text "blue" "ohmytool: " "false"
            print_text "white" "One-click installation and environment setup toolkit. Type " "false"
            print_text "green" "$ ohmytool " "false"
            print_text "white" "see all the available functions. " "false"
            printf "\n"
            for k in "${(@k)manual_ohmytool}"; do
                printf "\t\t"
                print_text "green" "$k: " "false"
                print_text "white" "${manual_ohmytool[$k]}" "false"
                printf "\n"
            done
                done
            else
                print_error "Only zsh shell is supported for this feature!"
    fi
    print_line "cyan" $(tput cols)
}
# welcome message
if [ "${SHOW_GCR_INFO:-}" = "true" ]; then
    show_GCR_info
fi

# 3.main content

export PATH=$HOME:$PATH

source ~/.ohmyzsh
source ~/.p9k.zsh
source ~/.ohmytool

# support server-administration
if [ -d ~/.server-administration ];then
    source ~/.server-administration/init.sh
fi

# support PBShelper
if [ -d ~/.PBShelper ];then
    source ~/.PBShelper/init.sh
fi

# support safe-rm
if [ -f ~/.safe-rm ];then

    trash_dir=${SAFE_RM_TRASH:="$HOME/.Trash"}
    alias rm='~/.safe-rm'
    alias del='~/.safe-rm -rf'
    alias delf='/bin/rm -rf'

    empty_trash() {
        echo "Do you want to:"
        echo "1) Clear all files in the Trash"
        echo "2) Clear files not used for over 30 days in the Trash"
        echo -n "Enter your choice (1 or 2): "
        read choice

        case $choice in
            1)
                print_info "Clearing all files in the Trash..."
                /bin/rm -rf "$trash_dir"/*
                print_success "All files in the Trash have been cleared."
                ;;
            2)
                print_info "Clearing files not used for over 30 days in the Trash..."
                find "$trash_dir" -type f -mtime +30 -exec /bin/rm -f {} \;
                find "$trash_dir" -type d -empty -mtime +30 -exec rmdir {} \;
                print_success "Files not used for over 30 days in the Trash have been cleared."
                ;;
            *)
                print_error "Invalid choice. Please enter 1 or 2."
                ;;
        esac
    }
else
    printf "\n"
    print_line "red" $(tput cols)
    printf "  "
    print_text "yellow" "WARNING:" "false"
    printf " "
    print_text "white" "Your current 'rm' command is dangerous!" "false"
    printf "\n"
    printf "  "
    print_text "white" "Run " "false"
    print_text "green" "install_safe_rm" "false"
    print_text "white" " and restart your shell to enable safe deletion." "false"
    printf "\n"
    print_line "red" $(tput cols)
    printf "\n"
fi

# rewite vim and code
if [ -n "$SSH_CONNECTION" ]; then
    # remote server
    # support discard-vim
    if [ -f ~/.rmate ];then
        alias code='~/.rmate -p $RmatePort'
    fi
else
    # open with vs code (local)
    alias code='open -a "Visual Studio Code"'
fi

ohmyshell(){
    print_table_text "GCR Command Reference" "false" "cyan" "green" $(tput cols)
    printf "\n"

    printf "  "
    print_text "green" "myupdate    " "false"
    print_text "white" "Update GCR Toolkit from GitHub" "false"
    printf "\n"

    printf "  "
    print_text "green" "mytool      " "false"
    print_text "white" "Common tools for daily tasks" "false"
    printf "\n"

    printf "  "
    print_text "green" "mypip       " "false"
    print_text "white" "Python pip management tools" "false"
    printf "\n"

    printf "  "
    print_text "green" "myenv       " "false"
    print_text "white" "Anaconda environment management" "false"
    printf "\n"

    printf "  "
    print_text "green" "mygpu       " "false"
    print_text "white" "GPU and CUDA utilities" "false"
    printf "\n"

    printf "  "
    print_text "green" "mypermission" "false"
    print_text "white" " Permission and password management" "false"
    printf "\n"

    printf "  "
    print_text "green" "mygit       " "false"
    print_text "white" "Git workflow shortcuts" "false"
    printf "\n"

    printf "\n"
    print_line "green" $(tput cols)
}

# >>> mytool >>>
# Funtion:
# 1. jp - open jupyter lab
# 2. listen - ssh port forwarding
# 3. pathadd - add environment variable to PATH 
# 4. condainit - set conda initial and add startup shell to bashrc/zshrc
# 5. sz - view folder and file size
# 6. listen_vpn - listen remote server vpn (Only support Local)
# 7. download_googledrive - download file from google drive

# open jupyter notebook
jp(){
    print_table_text "Jupyter notebook starting..." "false" "green" "cyan" $(tput cols)
    if [ -z "$JupyterPort" ]; then
        print_text "green" "Input port: " "false"
        read port
    else
        port=$JupyterPort
    fi
    jupyter lab --port ${port} --no-browser
}

# ssh -NL
listen(){
    print_table_text "This is a funtion for SSH port forwarding. It has 3 modes." "false" "green" "cyan" $(tput cols)
    print_text "green" "[1] -L :Local Forwarding - Local port listen the remote port." "false"
    printf "\n"
    print_text "green" "[2] -R :Remote Forwarding - Remote port listen the local port." "false"
    printf "\n"
    print_text "green" "[3] -D :Dynamic Forwarding - Use remote to forward local port. (socks5)" "false"
    printf "\n"
    print_text "green" "Your choose(default: 1): " "false"
    read func_num
    if [[ "${func_num}" = 1 ]] || [[ "${func_num}" = "" ]];then
        echo '[1] -L :Local Forwarding - Local port listen the remote port.'
        print_text "green" "Known hosts: " "false"
        print_text "yellow" "$(awk '/^\s*Host/ { printf "%s | ", $2 }' ~/.ssh/config)" "false"
        printf "\n"
        echo -e 'The Host: \c'
        read Host
        echo -e 'The Remote Port: \c'
        read RPort
        echo -e 'The Local Port (default: = Remote Port): \c'
        read LPort
        if [ "${LPort}" = "" ];then
            LPort=${RPort}
        fi
        printf "\n"
        echo '$ ssh -L localhost:'"$LPort"':localhost:'"$RPort"' '"$Host"' -N'
        echo -e "Running at: \033[4mhttp://localhost:${LPort}\033[0m"
        ssh -L localhost:${LPort}:localhost:${RPort} ${Host} -N

    elif [ "${func_num}" = 2 ];then
        echo '[2] -R :Remote Forwarding - Remote port listen the local port.'
        echo -e 'The Host: \c'
        read Host
        echo -e 'The Local Port: \c'
        read LPort
        echo -e 'The Remote Port (default: = Local Port): \c'
        read RPort
        if [ "${RPort}" = "" ];then
            RPort=${LPort}
        fi
        printf "\n"
        echo -e "$ ssh -R localhost:$RPort"':localhost:'"$LPort $Host -N"
        ssh -R localhost:${RPort}:localhost:${LPort} ${Host} -N
    elif [ "${func_num}" = 3 ];then
        echo '[3] -D :Dynamic Forwarding - Use remote to forward local port. (socks5)'
        echo -e 'The Host: \c'
        read Host
        echo -e 'The LPort Port: \c'
        read LPort
        printf "\n"
        echo -e "$ ssh -D $LPort $Host -N"
        ssh -D ${LPort} ${Host} -N
    else
        print_error "Invalid input! Please enter a valid option number."
    fi
    unset func_num
}

# add environment variable to PATH
pathadd(){
    print_table_text "This is a funtion to add environment variable to PATH." "false" "green" "cyan" $(tput cols)
    print_text "green" "path: " "false"
    read pth
    print_text "green" "whether to add to ${shell_file} (add permanently)? ([y]/n)? " "false"
    read yon
    if [ "${yon}" = "y" ];then
        echo '# >>> [Added by .ohmyshell] Add PATH to env >>>' >> ${shell_file}
        echo "export PATH=${pth}:"'$PATH' >> ${shell_file}
        echo '# <<< [Added by .ohmyshell] Add PATH to env end <<<' >> ${shell_file}
    else
        export PATH=${pth}:$PATH
    fi
    unset pth
    unset yon
}

# Set conda initial and add startup shell to bashrc/zshrc.
condainit(){
    print_table_text "This is a funtion to set conda initial and add startup shell to bashrc/zshrc." "false" "green" "cyan" $(tput cols)
    print_text "green" "anaconda installed path (e.g. /usr/local/anaconda3): " "false"
    read pth
    cpth=${pth}'/etc/profile.d/conda.sh'
    print_text "green" "whether to add [source ${cpth}] to ${shell_file}? ([y]/n)? " "false"
    read yon
    yon=${yon:-y}
    if [ "${yon}" = "y" ];then
        echo '# >>> [Added by .ohmyshell] Conda initial >>>' >> ${shell_file}
        echo "source ${cpth}" >> ${shell_file}
        echo '# <<< [Added by .ohmyshell] Conda initial end <<<' >> ${shell_file}
        echo "Complete add [source ${cpth}] to ${shell_file}"
    fi
    unset yon
}

# view folder and file size
# TODO: add some param such like sz $1 $2
sz(){
    print_table_text "This is a funtion to view folder and file information." "false" "green" "cyan" $(tput cols)
    print_text "green" "Choose the Function [Number] you want:" "false"
    printf "\n"
    print_text "green" "[1] view all computer disk size" "false"
    printf "\n"
    print_text "green" "[2] view folder or file size" "false"
    printf "\n"
    print_text "green" "[3] view file number in folder" "false"
    printf "\n"
    print_text "green" "Your choose: " "false"
    read func_num
    if [ "${func_num}" = 1 ];then
        print_text "green" "$ df -h" "false"
        printf "\n"
        df -h
    elif [ "${func_num}" = 2 ];then
        print_text "green" "Input the folder or file to view (default: *, not support ~): " "false"
        read fod_name
        print_text "green" "Input the max depth to view (default: 0): " "false"
        read max_depth

        if [ "${max_depth}" = "" ];then
            max_depth=0
        fi
        # Different for MacOs and Linux
        if [ "$(uname -s)" = Linux ];then
            if [[ "${fod_name}" = "" ]] || [[ "${fod_name}" = "*" ]];then
                print_text "green" "$ du -h --max-depth=${max_depth} *" "false"
                printf "\n"
                du -h --max-depth=${max_depth} *
            else
                print_text "green" "$ du -h --max-depth=${max_depth} ${fod_name}" "false"
                printf "\n"
                du -h --max-depth=${max_depth} ${fod_name}
            fi
        elif [ "$(uname -s)" = Darwin ];then
            if [[ "${fod_name}" = "" ]] || [[ "${fod_name}" = "*" ]];then
                print_text "green" "$ du -h -d ${max_depth} *" "false"
                printf "\n"
                du -h -d ${max_depth} *
            else
                print_text "green" "$ du -h -d ${max_depth} ${fod_name}" "false"
                printf "\n"
                du -h -d ${max_depth} ${fod_name}
            fi
        else
            print_text "red" "Not support current OS!" "false"
        fi
    elif [ "${func_num}" = 3 ];then
        print_text "green" "Input the folder to view (default: .): " "false"
        read fod_name
        fod_name=${fod_name:.}
        print_text "green" "Input the file type to view ([A]ll, [D]irectory, [F]ile, [L]ink): " "false"
        read file_type
        file_type=${file_type:-A}
        # A or a both the same, the same as D, F, L
        if [ "${file_type}" = "A" ] || [ "${file_type}" = "a" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^" "false"
            ls -l ${fod_name} | grep -c ^
        elif [ "${file_type}" = "D" || [ "${file_type}" = "d" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^d" "false"
            ls -l ${fod_name} | grep -c ^d
        elif [ "${file_type}" = "F" || [ "${file_type}" = "f" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^-" "false"
            ls -l ${fod_name} | grep -c ^-
        elif [ "${file_type}" = "L" || [ "${file_type}" = "l" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^l" "false"
            ls -l ${fod_name} | grep -c ^l
        else
            print_error "Invalid file type! Please enter A, D, F, or L."
        fi

    else
        print_error "Invalid input! Please enter a valid option number."
    fi
}

# listen remote server vpn (Only support Local)
listen_vpn(){
    echo 'Listen remote server vpn (Only support Local)'
    echo -e 'The Host: \c'
    read listen_vpn_Host
    echo -e 'The Local Port: \c'
    read listen_vpn_LPort
    echo -e "$ ssh -NL localhost:${listen_vpn_LPort}:localhost:9090 ${listen_vpn_Host}"
    echo -e "Running at: 
    \033[4mhttp://clash.razord.top\033[0m
    Host: 120.0.0.1
    Port: Local Port
    HTTP proxy port: 7890
    Socks5 proxy port: 7891
    Mode: Rules"
    ssh -NL localhost:${listen_vpn_LPort}:localhost:9090 ${listen_vpn_Host}
}

# download file from google drive
download_googledrive(){
    echo -e 'This is a funtion to download file/files from google drive.'

    # Method 1: use wget to download
    # echo -e 'file ID: \c'
    # read fileid
    # echo -e 'file Name: \c'
    # read filename
    # echo -e "$ wget --load-cookies /tmp/cookies.txt \"https://drive.google.com/uc?export=download\&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://drive.google.com/uc?export=download&id=${fileid}' -O- | sed -rn 's/.confirm=([0-9A-Za-z_]+)./\1\n/p')&id=${fileid}\" -O ${filename} && rm -rf /tmp/cookies.txt"
    # wget --load-cookies /tmp/cookies.txt "https://drive.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://drive.google.com/uc?export=download&id=${fileid}' -O- | sed -rn 's/.confirm=([0-9A-Za-z_]+)./\1\n/p')&id=${fileid}" -O ${filename} && rm -rf /tmp/cookies.txt

    # Method 2: use gdown -  pip install gdown
    echo -e 'file(s) ID: \c'
    read fileid
    echo -e "whether a file folder? ([y]/n)? \c"
    read yon
    if [ "${yon}" = "y" ];then
        gdown ${fileid}
    else
        gdown --folder ${fileid}
    fi
}

# test vps
vpstest(){
    echo 'Test the vps.'
    bash <(curl -sL https://raw.githubusercontent.com/LloydAsp/NodeBench/main/NodeBench.sh)
}

# Integrate all tool commands
mytool(){
    print_table_text "mytool - Tool Selection Menu" "false" "cyan" "green" $(tput cols)
    printf "\n"
    echo -e '  [1] jp            - Open Jupyter Lab'
    echo -e '  [2] listen        - SSH port forwarding'
    echo -e '  [3] pathadd       - Add to PATH'
    echo -e '  [4] condainit     - Initialize Conda'
    echo -e '  [5] sz            - View disk usage'
    echo -e '  [6] listen_vpn    - Listen VPN (Local only)'
    echo -e '  [7] download_gd   - Download from Google Drive'
    echo -e '  [8] vpstest       - Test VPS performance'
    printf "\n"
    print_line "green" $(tput cols)
    echo -e '\nInput your choice: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        jp
    elif [ "${func_num}" = 2 ];then
        listen
    elif [ "${func_num}" = 3 ];then
        pathadd
    elif [ "${func_num}" = 4 ];then
        condainit
    elif [ "${func_num}" = 5 ];then
        sz
    elif [ "${func_num}" = 6 ];then
        listen_vpn
    elif [ "${func_num}" = 7 ];then
        download_googledrive
    elif [ "${func_num}" = 8 ];then
        vpstest
    else
        print_error "Invalid input! Please enter a number between 1-8."
    fi
}
# <<< myool end <<<

# >>> mypip >>>
# Function:
# 1. pipset - modify pip source
# 2. pipbase - pip install some base module
# 3. pipl - pip list and pip show
# 4. pipi - pip install
# 5. pipu - pip uninstall

# modify pip source
pipset(){
    THU_SOURCE=https://pypi.tuna.tsinghua.edu.cn/simple
    ALI_SOURCE=https://mirrors.aliyun.com/pypi/simple/
    TENCENT_SOURCE=http://mirrors.cloud.tencent.com/pypi/simple
    echo -e 'pip source:'
    echo -e '[1] Tsinghua Source'
    echo -e '[2] ALibaba Source'
    echo -e '[3] Tencent Source'
    echo -e 'Input your choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        SOURCE=${THU_SOURCE}
    elif [ "${func_num}" = 2 ];then
        SOURCE=${ALI_SOURCE}
    elif [ "${func_num}" = 3 ];then
        SOURCE=${TENCENT_SOURCE}
    else
        SOURCE=${THU_SOURCE}
        echo -e 'Invalid Input! Using THU default.'

    fi
    echo -e "$ pip config set global.index-url ${SOURCE}"
    pip config set global.index-url ${SOURCE}
}

# pip install some base module
pipbase(){
    unset i
    unset yon
    base_module=('pygments' 'gpustat' 'jupyterlab' 'tensorboard' 'woaigpu' 'gdown' 'shell-gpt')
    for i in ${base_module}; do
        print_text "green" "whether to $ pip install ${i} (y/[n])?" "false"
        read yon
        yon=${yon:-n}
        if [ "${yon}" = "y" ]; then
            pip install ${i}
        fi
    done
    unset i
    unset yon
}

# pip list and pip show
pipl(){
    if [ "${1}" = "" ]; then
        echo '$ pip list'
        pip list
    else
        echo -e "$ pip show ${1}"
        pip show ${1}
    fi
}

# pip install
pipi(){
    if [ "${1}" = "" ]; then
        echo -e 'whether to $ pip install req*.txt? ([y]/n)? \c'
        read yon
        yon=${yon:-y}
        if [ "${yon}" = "y" ];then
            pip install -r req*.txt
        fi
    else
        echo -e "$ pip install $@"
        pip install "$@"
    fi
}

# pip uninstall
pipu(){
    if [ "${1}" = "" ]; then
        pipl
        echo -e 'choose which to uninstall: \c'
        read pkg
        pip uninstall ${pkg} 
    else
       pip uninstall "$@"
    fi
}

# Integrate all tool commands
mypip(){
    print_table_text "mypip - Python Package Management" "false" "cyan" "green" $(tput cols)
    printf "\n"
    echo -e '  [1] pipset   - Configure pip source'
    echo -e '  [2] pipbase  - Install base packages'
    echo -e '  [3] pipl     - List/show packages'
    echo -e '  [4] pipi     - Install packages'
    echo -e '  [5] pipu     - Uninstall packages'
    printf "\n"
    print_line "green" $(tput cols)
    echo -e '\nInput your choice: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        pipset
    elif [ "${func_num}" = 2 ];then
        pipbase
    elif [ "${func_num}" = 3 ];then
        pipl
    elif [ "${func_num}" = 4 ];then
        pipi
    elif [ "${func_num}" = 5 ];then
        pipu
    else
        print_error "Invalid input! Please enter a number between 1-5."
    fi
}
# <<< mypip end <<<

# >>> myenv >>>
# Funtion:
# 1. env - Activate an environment
# 2. lenv - List installed environments
# 3. cenv - Create new environments
# 4. denv - Delete an installed environment

# conda activate
env() {
    if [ -z "$1" ]; then
        print_section "Conda Environments" "cyan"

        # 获取conda环境列表
        conda_env_list=$(conda env list | tail -n +3)

        # 如果没有环境
        if [ -z "$conda_env_list" ]; then
            print_warning "No conda environments found"
            return 1
        fi

        # 获取终端宽度
        terminal_width=$(tput cols)

        # 计算合适的列宽
        env_name_width=$((terminal_width * 30 / 100))
        location_width=$((terminal_width * 60 / 100))

        # 打印表头
        printf "  "
        print_text "cyan" "$(printf "%-*s" "$env_name_width" "Environment")" "false"
        print_text "green" "$(printf "%-*s" "$location_width" "Location")" "false"
        print_text "yellow" "Status" "false"
        printf "\n"

        printf "  "
        for ((i = 0; i < terminal_width - 4; i++)); do
            printf "─"
        done
        printf "\n"

        # 打印conda环境列表
        echo "$conda_env_list" | while IFS= read -r line; do
            # 跳过空行和注释
            [[ -z "$line" || "$line" == \#* ]] && continue

            if [[ "$line" == *"*"* ]]; then
                # 当前激活的环境 - 格式: name  *  path
                env_name=$(echo "$line" | awk '{print $1}')
                location=$(echo "$line" | awk '{for(i=3;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ *$//')

                printf "  "
                print_text "cyan" "$(printf "%-*s" "$env_name_width" "$env_name")" "false"
                print_text "white" "$(printf "%-*s" "$location_width" "$location")" "false"
                print_text "green" "● Active" "false"
                printf "\n"
            else
                # 非激活环境 - 格式: name  path
                env_name=$(echo "$line" | awk '{print $1}')
                location=$(echo "$line" | awk '{for(i=2;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ *$//')

                printf "  "
                print_text "white" "$(printf "%-*s" "$env_name_width" "$env_name")" "false"
                print_text "white" "$(printf "%-*s" "$location_width" "$location")" "false"
                print_text "white" "○" "false"
                printf "\n"
            fi
        done

        printf "\n"
        print_line "cyan" $(tput cols)
        printf "\n"

        # 提取环境名称列表（排除空行和注释）
        condaenvs=$(echo "$conda_env_list" | grep -v '^#' | grep -v '^$' | awk '{print $1}')

        # 根据shell类型生成环境数组
        if [[ "$SHELL" == *"zsh" ]]; then
            envs_array=("${(f)condaenvs}")
        elif [[ "$SHELL" == *"bash" ]]; then
            IFS=$'\n' read -r -d '' -a envs_array <<< "$condaenvs"
        else
            print_error "Invalid shell type: $SHELL"
            return 1
        fi

        # 创建选择菜单
        print_text "cyan" "Select environment to activate:" "false"
        printf "\n\n"

        local count=1
        for env_item in "${envs_array[@]}"; do
            printf "  "
            print_text "yellow" "[$count]" "false"
            printf " "
            print_text "white" "$env_item" "false"
            printf "\n"
            ((count++))
        done

        printf "  "
        print_text "yellow" "[$count]" "false"
        printf " "
        print_text "red" "deactivate" "false"
        printf "\n\n"

        print_prompt "Your choice" ""
        read choice

        # 验证输入是否为数字
        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            print_error "Please enter a valid number"
            return 1
        fi

        if [ "$choice" = "$count" ]; then
            print_info "Deactivating conda environment..."
            conda deactivate
            print_success "Environment deactivated"
        elif [ "$choice" -ge 1 ] && [ "$choice" -lt "$count" ]; then
            # 根据shell类型获取正确的数组元素
            if [[ "$SHELL" == *"zsh" ]]; then
                # zsh数组从1开始
                selected_env="${envs_array[$choice]}"
            else
                # bash数组从0开始
                selected_env="${envs_array[$((choice - 1))]}"
            fi

            print_info "Activating environment: $selected_env"
            conda activate "$selected_env"
            print_success "Environment activated: $selected_env"
        else
            print_error "Invalid choice. Please enter a number between 1 and $count"
        fi
    else
        conda activate "$1"
    fi
}

# list conda envs
alias lenv='conda info -e'

# create conda env
cenv(){
    echo -e 'The name of the environment to create: \c'
    read Env_name
    conda env list
    echo -e 'Copy from existing env (default no copy): \c'
    read Source_Env_name
    if [ "${Source_Env_name}" = "" ];then
        echo -e 'Python version (default 3.7): \c'
        read Py_version
        if [ "${Py_version}" = "" ];then
            echo -e "$ conda create --name ${Env_name} python=3.7 ipykernel -y"
            conda create --name ${Env_name} python=3.7 ipykernel -y
            echo -e "$ python -m ipykernel install --user --name ${Env_name}"
            python -m ipykernel install --user --name ${Env_name}
        else
            echo -e "$ conda create --name ${Env_name} python=${Py_version} ipykernel -y"
            conda create --name ${Env_name} python=${Py_version} ipykernel -y
            echo -e "$ python -m ipykernel install --user --name ${Env_name}"
            python -m ipykernel install --user --name ${Env_name}
        fi
    else
        conda create --name ${Env_name} --clone ${Source_Env_name}
    fi
}

# delete conda env
denv(){
    conda env list
    echo -e 'The name of the environment to delete: \c'
    read Env_name
    echo -e "Do you want to delete the environment: ${Env_name}? ([y]/n)? \c"
    read yon
    if [ "${yon}" = "y" ];then
        echo -e "$ conda remove -n ${Env_name} --all"
        conda remove -n ${Env_name} --all
    else
        echo -e "${Env_name} not deleted."
    fi
}

# Integrate all conda commands
myenv(){
    print_table_text "myenv - Conda Environment Management" "false" "cyan" "green" $(tput cols)
    printf "\n"
    echo -e '  [1] env    - Activate environment'
    echo -e '  [2] lenv   - List environments'
    echo -e '  [3] cenv   - Create environment'
    echo -e '  [4] denv   - Delete environment'
    printf "\n"
    print_line "green" $(tput cols)
    echo -e '\nInput your choice: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        env
    elif [ "${func_num}" = 2 ];then
        lenv
    elif [ "${func_num}" = 3 ];then
        cenv
    elif [ "${func_num}" = 4 ];then
        denv
    else
        print_error "Invalid input! Please enter a number between 1-4."
    fi
}
# <<< myenv end <<<

# >>> mygpu >>>
# Function:
# 1. gpu - gpustat realtime
# 2. nvidia - nvidia-smi realtime
# 3. pid - view pids for all gpus
# 4. gpus - CUDA_VISIBLE_DEVICES

# gpu listen
alias gpu='gpustat -i 0.2 -p'
alias nvidia='watch -n 0.2 nvidia-smi'
alias gpus='echo "CUDA_VISIBLE_DEVICES"'

# View pids for all gpus 
pid(){
    echo -e "Use sudo? ([y]/n)? \c"
    read yon
    if [ "${yon}" = "y" ];then
        echo '$ sudo fuser -v /dev/nvidia*'
        sudo fuser -v /dev/nvidia*
    else
        echo '$ fuser -v /dev/nvidia*'
        fuser -v /dev/nvidia*
    fi
}

# Integrate all GPU commands
mygpu(){
    print_table_text "mygpu - GPU Management Tools" "false" "cyan" "green" $(tput cols)
    printf "\n"
    echo -e '  [1] gpu      - GPU status (gpustat)'
    echo -e '  [2] nvidia   - GPU status (nvidia-smi)'
    echo -e '  [3] pid      - View GPU process IDs'
    echo -e '  [4] gpus     - Show CUDA devices'
    printf "\n"
    print_line "green" $(tput cols)
    echo -e '\nInput your choice: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        gpu
    elif [ "${func_num}" = 2 ];then
        nvidia
    elif [ "${func_num}" = 3 ];then
        pid
    elif [ "${func_num}" = 4 ];then
        echo 'CUDA_VISIBLE_DEVICES'
    else
        print_error "Invalid input! Please enter a number between 1-4."
    fi
}
# <<< GPU end <<<

# >>> mypermission >>>
# Function:
# 1. mychmod - modify directory permissions levels
# 2. mychown - modify directory owners
# 3. passwd - change passwards

# chmod
mychmod(){
    echo -e 'This is a funtion for [chmod] to modify directory permission levels.'
    echo -e 'Input directory: \c'
    read dir
    if [ -d "${dir}" ];then
        echo -e 'Input permission level (e.g. 777): \c'
        read permission
        echo -e "Do you want to change the directory [${dir}] to [${permission}]? ([y]/n)? \c"
        read yon
        if [ "${yon}" = "y" ];then
            echo -e "Use sudo? ([y]/n)? \c"
            read yyon
            if [ "${yyon}" = "y" ];then
                echo -e "$ sudo chmod -R ${permission} ${dir}"
                sudo chmod -R ${permission} ${dir}
            else
                echo -e "$ chmod -R ${permission} ${dir}"
                chmod -R ${permission} ${dir}
            fi
        fi
    else
        echo -e 'Invalid direcctory!'
    fi
}

# chown 
mychown(){
    echo -e 'This is a funtion for [chown] to modify directory owners.'
    echo -e 'Input directory: \c'
    read dir
    if [ -d "${dir}" ];then
        echo -e 'Input new owner (user or user:group): \c'
        read owner
        echo -e "Do you want to change the directory [${dir}] to the owner [${owner}]? ([y]/n)? \c"
        read yon
        if [ "${yon}" = "y" ];then
            echo -e "Use sudo? ([y]/n)? \c"
            read yyon
            if [ "${yyon}" = "y" ];then
                echo -e "$ sudo chown -R ${owner} ${dir}"
                sudo chown -R ${owner} ${dir}
            else
                echo -e "$ chown -R ${owner} ${dir}"
                chown -R ${owner} ${dir}
            fi
        fi
    else
        echo -e 'Invalid direcctory!'
    fi
}

# Integrate all Permission commands
mypermission(){
    print_table_text "mypermission - Permission Management" "false" "cyan" "green" $(tput cols)
    printf "\n"
    echo -e '  [1] mychmod  - Modify directory permissions'
    echo -e '  [2] mychown  - Modify directory owners'
    echo -e '  [3] passwd   - Change password'
    printf "\n"
    print_line "green" $(tput cols)
    echo -e '\nInput your choice: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        mychmod
    elif [ "${func_num}" = 2 ];then
        mychown
    elif [ "${func_num}" = 3 ];then
        passwd
    else
        print_error "Invalid input! Please enter a number between 1-3."
    fi
}
# <<< mypermission end <<<

# >>> mygit >>>
# some git config
alias gita='git add'
alias gitaa='git add .'
alias gitb='git branch'
gitc(){
    echo -e 'Commit content: \c'
    read commit
    git commit -m ${commit}
}
alias gitl='git log'
alias gitr='git reset'
alias gc='git clone'
gitch(){
    if [ "${1}" = "" ]; then
        gitb
        echo -e 'which branch to checkout: \c'
        read branch_name
        git checkout ${branch_name};
	else
		git checkout ${1}
	fi
}
alias gitps='git push origin master'
alias gitpl='git pull'
alias gitst='git status'

# Integrate all Git commands
mygit(){
    print_table_text "mygit - Git Workflow Shortcuts" "false" "cyan" "green" $(tput cols)
    printf "\n"
    echo -e '  [1]  gita   - git add'
    echo -e '  [2]  gitaa  - git add .'
    echo -e '  [3]  gitc   - git commit'
    echo -e '  [4]  gitl   - git log'
    echo -e '  [5]  gitr   - git reset'
    echo -e '  [6]  gc     - git clone'
    echo -e '  [7]  gitch  - git checkout'
    echo -e '  [8]  gitps  - git push origin master'
    echo -e '  [9]  gitpl  - git pull'
    echo -e '  [10] gitst  - git status'
    echo -e '  [11] gitb   - git branch'
    printf "\n"
    print_line "green" $(tput cols)
    echo -e '\nInput your choice: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        gita
    elif [ "${func_num}" = 2 ];then
        gitaa
    elif [ "${func_num}" = 3 ];then
        gitc
    elif [ "${func_num}" = 4 ];then
        gitl
    elif [ "${func_num}" = 5 ];then
        gitr
    elif [ "${func_num}" = 6 ];then
        gc
    elif [ "${func_num}" = 7 ];then
        gitch
    elif [ "${func_num}" = 8 ];then
        gitps
    elif [ "${func_num}" = 9 ];then
        gitpl
    elif [ "${func_num}" = 10 ];then
        gitst
    elif [ "${func_num}" = 11 ];then
        gitb
    else
        print_error "Invalid input! Please enter a number between 1-11."
    fi
}
# <<< mygit end <<<

# >>> Others >>>
# update bash/zsh profile
alias sc="source ${shell_file}"
# list directory
if [[ -f ~/.ruby/bin/colorls ]] || [[ -f /usr/local/bin/colorls ]];then
    if [[ -f ~/.ruby/bin/colorls ]];then
        export PATH=~/.ruby/bin:$PATH
    fi
    alias ls='colorls --sd'
    alias la='colorls --sd --all'
    alias ll='colorls --sd --all -l'
    alias tree='colorls --tree'
else
    alias ll='ls -alF'
    alias la='ls -A'
    alias l='ls -CF'
fi

# support joshuto
if command -v joshuto >/dev/null 2>&1; then
    alias l='joshuto'
fi
if [[ -f $HOME/.joshuto/target/release/joshuto ]]; then
    alias l='$HOME/.joshuto/target/release/joshuto'
fi

# clear terminal
alias cl='clear'
# view code with format
alias pcat='pygmentize -g'
# open tensorboard with tb
tb() {
  if [ -n "$TensorboardPort" ]; then
    tensorboard --logdir=./ --port="$TensorboardPort"
  else
    tensorboard --logdir=./
  fi
}
# download files or folder
download() {
  if [ $# -ge 1 ]; then
    tsz -r "$@"
  else
    PS3='Please select a file or folder to download: '
    select file in *; do
      if [ -n "$file" ]; then
        tsz -r "$file"
        break
      else
        echo "Invalid selection, please make a new selection."
      fi
    done
    unset PS3
  fi
}

# upload folder
upload(){
    print_table_text "Upload Files/Folders" "false" "cyan" "green" $(tput cols)
    printf "\n"
    echo -e '  [1] File(s)'
    echo -e '  [2] Folder(s)'
    printf "\n"
    print_line "green" $(tput cols)
    echo -e '\nYour choice: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        trz
    elif [ "${func_num}" = 2 ];then
        trz -r
    else
        print_error "Invalid input! Please enter 1 or 2."
    fi
}
# open ssh with tssh --dragfile

alias tssh='tssh --dragfile'
alias tsshd='tssh --dragfile'

# VPN commands (only for Linux)
startvpn(){
    echo 'Start VPN in terminal!'
    echo 'Must be install vpn before. If not, run install_vpn for linux.'
    echo -e "socks5 proxy(default: 7891): \c"
    read all_port
    echo -e "http proxy(default: 7890): \c"
    read http_port
    echo -e "https proxy(default: 7890): \c"
    read https_port
    if [ "${all_port}" = "" ];then
        all_port=7891
    fi
    if [ "${http_port}" = "" ];then
        http_port=7890
    fi
    if [ "${https_port}" = "" ];then
        https_port=7890
    fi
    echo -e "$ export ALL_PROXY=socks5://127.0.0.1:${all_port}"
    echo -e "$ export http_proxy=http://127.0.0.1:${http_port}"
    echo -e "$ export https_proxy=http://127.0.0.1:${https_port}"
    export ALL_PROXY=socks5://127.0.0.1:${all_port}
    export http_proxy=http://127.0.0.1:${http_port}
    export https_proxy=http://127.0.0.1:${https_port}
    echo 'You can see status by $ curl cip.cc / $ curl -x $ALL_PROXY cip.cc'

}
alias stopvpn='echo \
"Stop VPN in terminal!
You can see status by $ curl cip.cc" \
&& unset ALL_PROXY && unset http_proxy && unset https_proxy'

# a uniform function to view files with different formats
uview(){
    if [ "${1}" = "" ]; then
        echo -e 'File Name: \c'
        read filename
	else
		filename=${1}
	fi

    if [ -f ${filename} ];then
        case "${filename}" in
            *.bam ) samtools view ${filename} | less -S;;
            * ) echo "Not support this format. Supported formats: [.bam]";;
        esac
    else
        echo "${filename} not exist."
    fi
}

# add to docker group
dockeradd(){
    print_text "green" "This is a funtion to add user to docker group." "false"
    printf "\n"
    print_text "green" "Input the user to add (default: $(whoami)):" "false"
    read user
    user=${user:-$(whoami)}
    sudo gpasswd -a $user docker     #将登陆用户加入到docker用户组中
    newgrp docker     #更新用户组
}

# <<< Others end <<<
