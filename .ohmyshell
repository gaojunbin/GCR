# =========How to use=============
# for bash
# >> echo 'source ~/.ohmyshell' >> ~/.bashrc
# for zsh
# >> echo 'source ~/.ohmyshell' >> ~/.zshrc
# =========Outline================
# --- myupdate - support update GCR Toolkit from GitHub Repo.
# |
# --- mytool - Some basic tools for common using.
# |
# --- mypip - pip tools.
# |
# --- myenv - Anaconda tools.
# |
# --- mygpu - useful functions for GPU and cuda.
# |
# --- mypermission - some functions for permission, passward, etc.
# |
# --- mygit - Git tools.
# |
# --- Others
# ========Outline end============

export PATH=$HOME:$PATH

# shell type [~/.bashrc or ~/.zshrc]
# support tabby shell working directory reporting
if [[ "$SHELL" == *"zsh" ]];then
    declare -A manual_ohmyshell=(
        ["myupdate"]="support update GCR Toolkit from GitHub Repo."
        ["mytool"]="Some basic tools for common using."
        ["mypip"]="pip tools."
        ["myenv"]="Anaconda tools."
        ["mygpu"]="useful functions for GPU and cuda."
        ["mypermission"]="some functions for permission, passward, etc."
        ["mygit"]="Git tools"
    )
    shell_file=~/.zshrc
    precmd () { echo -n "\x1b]1337;CurrentDir=$(pwd)\x07" }
elif [[ "$SHELL" == *"bash" ]];then
    shell_file=~/.bashrc
    export PS1="$PS1\[\e]1337;CurrentDir="'$(pwd)\a\]'
else
    echo 'Invalid shell type: ' $SHELL
fi

# autoinstall
if [ ! -f ~/.ohmyshell ];then
    curl -o ~/.ohmyshell https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyshell
fi
if [ ! -f ~/.ohmyzsh ];then
    curl -o ~/.ohmyzsh https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyzsh
fi
if [ ! -f ~/.p9k.zsh ];then
    curl -o ~/.p9k.zsh https://raw.githubusercontent.com/gaojunbin/GCR/master/.p9k.zsh
fi
if [ ! -f ~/.ohmyprint ];then
    curl -o ~/.ohmyprint https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyprint
fi
if [ ! -f ~/.ohmytool ];then
    curl -o ~/.ohmytool https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmytool
fi
if [ ! -f ~/.vimrc ];then
    curl -o ~/.vimrc https://raw.githubusercontent.com/gaojunbin/GCR/master/.vimrc
fi

source ~/.ohmytool
source ~/.ohmyprint

# support server-administration
if [ -d ~/.server-administration ];then
    source ~/.server-administration/init.sh
fi

# support PBShelper
if [ -d ~/.PBShelper ];then
    source ~/.PBShelper/init.sh
fi

# support safe-rm
if [ -f ~/.safe-rm ];then

    trash_dir=${SAFE_RM_TRASH:="$HOME/.Trash"}
    alias rm='~/.safe-rm'
    alias del='~/.safe-rm -rf'
    alias delf='/bin/rm -rf'

    empty_trash() {
        echo "Do you want to:"
        echo "1) Clear all files in the Trash"
        echo "2) Clear files not used for over 30 days in the Trash"
        echo -n "Enter your choice (1 or 2): "
        read choice

        case $choice in
            1)
                print_text "green" "Clearing all files in the Trash..." "true"
                printf "\n"
                /bin/rm -rf "$trash_dir"/*
                print_text "green" "All files in the Trash have been cleared." "false"
                printf "\n"
                ;;
            2)
                print_text "green" "Clearing files not used for over 30 days in the Trash..." "true"
                printf "\n"
                find "$trash_dir" -type f -mtime +30 -exec /bin/rm -f {} \;
                find "$trash_dir" -type d -empty -mtime +30 -exec rmdir {} \;
                print_text "green" "Files not used for over 30 days in the Trash have been cleared." "false"
                printf "\n"
                ;;
            *)
                echo "Invalid choice. Please enter 1 or 2."
                ;;
        esac
    }
else
    echo '[ GCR Warning ] Your current `rm` is dangerous! Please run [install_safe_rm] first and restart your shell.'
fi

# rewite vim and code
if [ -n "$SSH_CONNECTION" ]; then
    # remote server
    # support discard-vim
    if [ -f ~/.rmate ];then
        alias code='~/.rmate -p $RmatePort'
    fi
else
    # open with vs code (local)
    alias code='open -a "Visual Studio Code"'
fi

show_update_info(){
    star_line=""
    for ((i = 0; i < $(tput cols); i++)); do
            star_line+="*"
    done
    print_text "green" $star_line "true"
    printf "\n"
    printf "\n"
    print_text "yellow" "🔥 Recent Updates 🔥" "false" $(tput cols)
    printf "\n"
    printf "\n"
    print_text "green" $star_line "true"
    printf "\n"
    printf "\n"
    print_line "cyan" $(tput cols)
    curl https://raw.githubusercontent.com/gaojunbin/GCR/master/recent_updates
    printf "\n"
    print_line "cyan" $(tput cols)
}

show_GCR_info(){
    star_line=""
    for ((i = 0; i < $(tput cols); i++)); do
            star_line+="*"
    done
    print_text "green" $star_line "true"
    printf "\n"
    printf "\n"
    print_text "yellow" "Welcome to GCR Toolkit!" "false" $(tput cols)
    printf "\n"
    printf "\n"
    print_text "green" $star_line "true"
    printf "\n"
    printf "\n"
    print_line "cyan" $(tput cols)
    print_text "cyan" "Basic Info:" "false"
    printf "\n"
    printf "\t"
    print_text "blue" "Author: " "false"
    print_text "white" "Junbin Gao" "false"
    printf "\n"
    printf "\t"
    print_text "blue" "Github: " "false"
    print_text "white" "https://github.com/gaojunbin/GCR" "false"
    printf "\n"
    printf "\t"
    print_text "blue" "Intro : " "false"
    print_text "white" "GCR is a shell plugin that makes it easier and more elegant to use the command line on a unix operating system without having to memorize cumbersome, retarded commands." "false"
    printf "\n"
    print_line "cyan" $(tput cols)
    if [[ "$SHELL" == *"zsh" ]];then
        for k in "${(@k)manual_ohmyshell}"; do
            print_text "cyan" "Manual:" "false"
            printf "\n"
            printf "\t"
            print_text "blue" "ohmyshell: " "false"
            print_text "white" "Some basic command in shell. Type " "false"
            print_text "green" "$ ohmyshell " "false"
            print_text "white" "see all the available functions. " "false"
            printf "\n"
            printf "\t\t"
            print_text "green" "$k: " "false"
            print_text "white" "${manual_ohmyshell[$k]}" "false"
            printf "\n"

            printf "\n"
            printf "\t"
            print_text "blue" "ohmytool: " "false"
            print_text "white" "One-click installation and environment setup toolkit. Type " "false"
            print_text "green" "$ ohmytool " "false"
            print_text "white" "see all the available functions. " "false"
            printf "\n"
            for k in "${(@k)manual_ohmytool}"; do
                printf "\t\t"
                print_text "green" "$k: " "false"
                print_text "white" "${manual_ohmytool[$k]}" "false"
                printf "\n"
            done
                done
            else
                printf "\t\t"
                print_text "green" "ERROR! Only support zsh!" "false"
                printf "\n"
    fi
    print_line "cyan" $(tput cols)
}
# welcome message
if [ "${SHOW_GCR_INFO:-}" = "true" ]; then
    show_GCR_info
fi

# GCR update time lock
GCR_update_file=$HOME/.gcr.update.lock
GCR_plugin_update_file=$HOME/.gcr.plugin.update.lock

gcr_need_update(){
    if [ "$(uname -s)" = Darwin ];then
        remote_ohmyshell_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyshell | md5)
        remote_ohmytool_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmytool | md5)
        remote_ohmyzsh_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyzsh | md5)
        remote_p9k_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.p9k.zsh | md5)
        remote_vimrc_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.vimrc | md5)
        remote_ohmyprint_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyprint | md5)

        local_ohmyshell_MD5=$(md5 -q ~/.ohmyshell)
        local_ohmytool_MD5=$(md5 -q ~/.ohmytool)
        local_ohmyzsh_MD5=$(md5 -q ~/.ohmyzsh)
        local_p9k_MD5=$(md5 -q ~/.p9k.zsh)
        local_vimrc_MD5=$(md5 -q ~/.vimrc)
        local_ohmyprint_MD5=$(md5 -q ~/.ohmyprint)

    elif [ "$(uname -s)" = Linux ];then
        remote_ohmyshell_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyshell | md5sum | awk '{print $1}')
        remote_ohmytool_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmytool | md5sum | awk '{print $1}')
        remote_ohmyzsh_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyzsh | md5sum | awk '{print $1}')
        remote_p9k_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.p9k.zsh | md5sum | awk '{print $1}')
        remote_vimrc_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.vimrc | md5sum | awk '{print $1}')
        remote_ohmyprint_MD5=$(curl -sL https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyprint | md5sum | awk '{print $1}')

        local_ohmyshell_MD5=$(md5sum ~/.ohmyshell | awk '{print $1}')
        local_ohmytool_MD5=$(md5sum ~/.ohmytool | awk '{print $1}')
        local_ohmyzsh_MD5=$(md5sum ~/.ohmyzsh | awk '{print $1}')
        local_p9k_MD5=$(md5sum ~/.p9k.zsh | awk '{print $1}')
        local_vimrc_MD5=$(md5sum ~/.vimrc | awk '{print $1}')
        local_ohmyprint_MD5=$(md5sum ~/.ohmyprint | awk '{print $1}')
    fi
        
    if [ "${remote_ohmyshell_MD5}" != "${local_ohmyshell_MD5}" ] || \
       [ "${remote_ohmytool_MD5}" != "${local_ohmytool_MD5}" ] || \
       [ "${remote_ohmyzsh_MD5}" != "${local_ohmyzsh_MD5}" ] || \
       [ "${remote_p9k_MD5}" != "${local_p9k_MD5}" ] || \
       [ "${remote_vimrc_MD5}" != "${local_vimrc_MD5}" ] || \
       [ "${remote_ohmyprint_MD5}" != "${local_ohmyprint_MD5}" ]; then
        
        return 0
    else
        return 1
    fi
}

# support update GCR Toolkit from GitHub Repo
myupdate(){
    print_table_text "Updating GCR ..." "true" "yellow" "red" $(tput cols)
    curl -o ~/.ohmyshell https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyshell
    curl -o ~/.ohmytool https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmytool 
    curl -o ~/.ohmyzsh https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyzsh
    curl -o ~/.p9k.zsh https://raw.githubusercontent.com/gaojunbin/GCR/master/.p9k.zsh
    curl -o ~/.vimrc https://raw.githubusercontent.com/gaojunbin/GCR/master/.vimrc
    curl -o ~/.ohmyprint https://raw.githubusercontent.com/gaojunbin/GCR/master/.ohmyprint
    date +%s > $GCR_update_file
    print_table_text "Success!" "false" "yellow" "red" $(tput cols)
    show_update_info
    source ${shell_file}
}

myupdateplug(){
    update_joshuto
    update_PBShelper
    update_tssh
    update_safe_rm
    date +%s > $GCR_plugin_update_file
    source ${shell_file}
}

# ==================Check Update (GCR)==================

find_gcr_update(){
    if gcr_need_update; then
        # if AUTO_GCR_UPDATE is not false, auto update
        if [ "${AUTO_GCR_UPDATE:-}" != "false" ]; then
            myupdate
        else
            show_update_info
            print_text "red" "GCR Toolkit has a newer version now! Type " "true"
            print_text "green" "$ myupdate " "true"
            print_text "red" "to update. " "true"
            printf "\n"
            date +%s > $GCR_update_file
        fi
    fi
}

# if CHECK_GCR_UPDATE is not false, check update every login
if [ "${CHECK_GCR_UPDATE:-}" != "false" ]; then
    find_gcr_update
fi

# ==================Auto Check Update per day (GCR & GCR plugin)==================
if [ -f "$GCR_update_file" ]; then
    last_timestamp=$(cat $GCR_update_file)
    current_timestamp=$(date +%s)

    if [[ "$last_timestamp" =~ ^[0-9]+$ ]]; then
        diff=$((current_timestamp - last_timestamp))
        # 1 days (86400s)
        if [ $diff -ge 86400 ]; then
            find_gcr_update
        fi
    else
        find_gcr_update
    fi
else
    find_gcr_update
fi

if [ -f "$GCR_plugin_update_file" ]; then
    last_timestamp=$(cat $GCR_plugin_update_file)
    current_timestamp=$(date +%s)

    if [[ "$last_timestamp" =~ ^[0-9]+$ ]]; then
        diff=$((current_timestamp - last_timestamp))
        # 1 days (86400s)
        if [ $diff -ge 86400 ]; then
            myupdateplug
        fi
    else
        myupdateplug
    fi
else
    myupdateplug
fi

ohmyshell(){
    print_table_text "List all func in .ohmyshell" "false" "green" "cyan" $(tput cols)
    print_text "green" "$ myupdate: " "false"
    print_text "white" "support update GCR Toolkit from GitHub Repo." "false"
    printf "\n"
    print_text "green" "$ mytool: " "false"
    print_text "white" "Some basic tools for common using." "false"
    printf "\n"
    print_text "green" "$ mypip: " "false"
    print_text "white" "pip tools." "false"
    printf "\n"
    print_text "green" "$ myenv: " "false"
    print_text "white" "Anaconda tools." "false"
    printf "\n"
    print_text "green" "$ mygpu: " "false"
    print_text "white" "useful functions for GPU and cuda." "false"
    printf "\n"
    print_text "green" "$ mypermission: " "false"
    print_text "white" "some functions for permission, passward, etc." "false"
    printf "\n"
    print_text "green" "$ mygit: " "false"
    print_text "white" "Git tools." "false"
    printf "\n"
    print_line "cyan" $(tput cols)
}

# >>> mytool >>>
# Funtion:
# 1. jp - open jupyter lab
# 2. listen - ssh port forwarding
# 3. pathadd - add environment variable to PATH 
# 4. condainit - set conda initial and add startup shell to bashrc/zshrc
# 5. sz - view folder and file size
# 6. listen_vpn - listen remote server vpn (Only support Local)
# 7. download_googledrive - download file from google drive

# open jupyter notebook
jp(){
    print_table_text "Jupyter notebook starting..." "false" "green" "cyan" $(tput cols)    
    print_text "green" "Input port: " "false"
    read port
    jupyter lab --port ${port} --no-browser
}

# ssh -NL
listen(){
    print_table_text "This is a funtion for SSH port forwarding. It has 3 modes." "false" "green" "cyan" $(tput cols)
    print_text "green" "[1] -L :Local Forwarding - Local port listen the remote port." "false"
    printf "\n"
    print_text "green" "[2] -R :Remote Forwarding - Remote port listen the local port." "false"
    printf "\n"
    print_text "green" "[3] -D :Dynamic Forwarding - Use remote to forward local port. (socks5)" "false"
    printf "\n"
    print_text "green" "Your choose(default: 1): " "false"
    read func_num
    if [[ "${func_num}" = 1 ]] || [[ "${func_num}" = "" ]];then
        echo '[1] -L :Local Forwarding - Local port listen the remote port.'
        print_text "green" "Known hosts: " "false"
        print_text "yellow" "$(awk '/^\s*Host/ { printf "%s | ", $2 }' ~/.ssh/config)" "false"
        printf "\n"
        echo -e 'The Host: \c'
        read Host
        echo -e 'The Remote Port: \c'
        read RPort
        echo -e 'The Local Port (default: = Remote Port): \c'
        read LPort
        if [ "${LPort}" = "" ];then
            LPort=${RPort}
        fi
        printf "\n"
        echo '$ ssh -L localhost:'"$LPort"':localhost:'"$RPort"' '"$Host"' -N'
        echo -e "Running at: \033[4mhttp://localhost:${LPort}\033[0m"
        ssh -L localhost:${LPort}:localhost:${RPort} ${Host} -N

    elif [ "${func_num}" = 2 ];then
        echo '[2] -R :Remote Forwarding - Remote port listen the local port.'
        echo -e 'The Host: \c'
        read Host
        echo -e 'The Local Port: \c'
        read LPort
        echo -e 'The Remote Port (default: = Local Port): \c'
        read RPort
        if [ "${RPort}" = "" ];then
            RPort=${LPort}
        fi
        printf "\n"
        echo -e "$ ssh -R localhost:$RPort"':localhost:'"$LPort $Host -N"
        ssh -R localhost:${RPort}:localhost:${LPort} ${Host} -N
    elif [ "${func_num}" = 3 ];then
        echo '[3] -D :Dynamic Forwarding - Use remote to forward local port. (socks5)'
        echo -e 'The Host: \c'
        read Host
        echo -e 'The LPort Port: \c'
        read LPort
        printf "\n"
        echo -e "$ ssh -D $LPort $Host -N"
        ssh -D ${LPort} ${Host} -N
    else
        echo -e 'Invalid Input!'
    fi
    unset func_num
}

# add environment variable to PATH
pathadd(){
    print_table_text "This is a funtion to add environment variable to PATH." "false" "green" "cyan" $(tput cols)
    print_text "green" "path: " "false"
    read pth
    print_text "green" "whether to add to ${shell_file} (add permanently)? ([y]/n)? " "false"
    read yon
    if [ "${yon}" = "y" ];then
        echo '# >>> [Added by .ohmyshell] Add PATH to env >>>' >> ${shell_file}
        echo "export PATH=${pth}:"'$PATH' >> ${shell_file}
        echo '# <<< [Added by .ohmyshell] Add PATH to env end <<<' >> ${shell_file}
    else
        export PATH=${pth}:$PATH
    fi
    unset pth
    unset yon
}

# Set conda initial and add startup shell to bashrc/zshrc.
condainit(){
    print_table_text "This is a funtion to set conda initial and add startup shell to bashrc/zshrc." "false" "green" "cyan" $(tput cols)
    print_text "green" "anaconda installed path (e.g. /usr/local/anaconda3): " "false"
    read pth
    cpth=${pth}'/etc/profile.d/conda.sh'
    print_text "green" "whether to add [source ${cpth}] to ${shell_file}? ([y]/n)? " "false"
    read yon
    yon=${yon:-y}
    if [ "${yon}" = "y" ];then
        echo '# >>> [Added by .ohmyshell] Conda initial >>>' >> ${shell_file}
        echo "source ${cpth}" >> ${shell_file}
        echo '# <<< [Added by .ohmyshell] Conda initial end <<<' >> ${shell_file}
        echo "Complete add [source ${cpth}] to ${shell_file}"
    fi
    unset yon
}

# view folder and file size
# TODO: add some param such like sz $1 $2
sz(){
    print_table_text "This is a funtion to view folder and file information." "false" "green" "cyan" $(tput cols)
    print_text "green" "Choose the Function [Number] you want:" "false"
    printf "\n"
    print_text "green" "[1] view all computer disk size" "false"
    printf "\n"
    print_text "green" "[2] view folder or file size" "false"
    printf "\n"
    print_text "green" "[3] view file number in folder" "false"
    printf "\n"
    print_text "green" "Your choose: " "false"
    read func_num
    if [ "${func_num}" = 1 ];then
        print_text "green" "$ df -h" "false"
        printf "\n"
        df -h
    elif [ "${func_num}" = 2 ];then
        print_text "green" "Input the folder or file to view (default: *, not support ~): " "false"
        read fod_name
        print_text "green" "Input the max depth to view (default: 0): " "false"
        read max_depth

        if [ "${max_depth}" = "" ];then
            max_depth=0
        fi
        # Different for MacOs and Linux
        if [ "$(uname -s)" = Linux ];then
            if [[ "${fod_name}" = "" ]] || [[ "${fod_name}" = "*" ]];then
                print_text "green" "$ du -h --max-depth=${max_depth} *" "false"
                printf "\n"
                du -h --max-depth=${max_depth} *
            else
                print_text "green" "$ du -h --max-depth=${max_depth} ${fod_name}" "false"
                printf "\n"
                du -h --max-depth=${max_depth} ${fod_name}
            fi
        elif [ "$(uname -s)" = Darwin ];then
            if [[ "${fod_name}" = "" ]] || [[ "${fod_name}" = "*" ]];then
                print_text "green" "$ du -h -d ${max_depth} *" "false"
                printf "\n"
                du -h -d ${max_depth} *
            else
                print_text "green" "$ du -h -d ${max_depth} ${fod_name}" "false"
                printf "\n"
                du -h -d ${max_depth} ${fod_name}
            fi
        else
            print_text "red" "Not support current OS!" "false"
        fi
    elif [ "${func_num}" = 3 ];then
        print_text "green" "Input the folder to view (default: .): " "false"
        read fod_name
        fod_name=${fod_name:.}
        print_text "green" "Input the file type to view ([A]ll, [D]irectory, [F]ile, [L]ink): " "false"
        read file_type
        file_type=${file_type:-A}
        # A or a both the same, the same as D, F, L
        if [ "${file_type}" = "A" ] || [ "${file_type}" = "a" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^" "false"
            ls -l ${fod_name} | grep -c ^
        elif [ "${file_type}" = "D" || [ "${file_type}" = "d" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^d" "false"
            ls -l ${fod_name} | grep -c ^d
        elif [ "${file_type}" = "F" || [ "${file_type}" = "f" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^-" "false"
            ls -l ${fod_name} | grep -c ^-
        elif [ "${file_type}" = "L" || [ "${file_type}" = "l" ];then
            print_text "green" "$ ls -l ${fod_name} | grep -c ^l" "false"
            ls -l ${fod_name} | grep -c ^l
        else
            print_text "red" "Invalid Input!" "false"
            echo 'Invalid Input!'
        fi

    else
        echo 'Invalid Input!'
    fi
}

# listen remote server vpn (Only support Local)
listen_vpn(){
    echo 'Listen remote server vpn (Only support Local)'
    echo -e 'The Host: \c'
    read listen_vpn_Host
    echo -e 'The Local Port: \c'
    read listen_vpn_LPort
    echo -e "$ ssh -NL localhost:${listen_vpn_LPort}:localhost:9090 ${listen_vpn_Host}"
    echo -e "Running at: 
    \033[4mhttp://clash.razord.top\033[0m
    Host: 120.0.0.1
    Port: Local Port
    HTTP proxy port: 7890
    Socks5 proxy port: 7891
    Mode: Rules"
    ssh -NL localhost:${listen_vpn_LPort}:localhost:9090 ${listen_vpn_Host}
}

# download file from google drive
download_googledrive(){
    echo -e 'This is a funtion to download file/files from google drive.'

    # Method 1: use wget to download
    # echo -e 'file ID: \c'
    # read fileid
    # echo -e 'file Name: \c'
    # read filename
    # echo -e "$ wget --load-cookies /tmp/cookies.txt \"https://drive.google.com/uc?export=download\&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://drive.google.com/uc?export=download&id=${fileid}' -O- | sed -rn 's/.confirm=([0-9A-Za-z_]+)./\1\n/p')&id=${fileid}\" -O ${filename} && rm -rf /tmp/cookies.txt"
    # wget --load-cookies /tmp/cookies.txt "https://drive.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://drive.google.com/uc?export=download&id=${fileid}' -O- | sed -rn 's/.confirm=([0-9A-Za-z_]+)./\1\n/p')&id=${fileid}" -O ${filename} && rm -rf /tmp/cookies.txt

    # Method 2: use gdown -  pip install gdown
    echo -e 'file(s) ID: \c'
    read fileid
    echo -e "whether a file folder? ([y]/n)? \c"
    read yon
    if [ "${yon}" = "y" ];then
        gdown ${fileid}
    else
        gdown --folder ${fileid}
    fi
}

# test vps
vpstest(){
    echo 'Test the vps.'
    bash <(curl -sL https://raw.githubusercontent.com/LloydAsp/NodeBench/main/NodeBench.sh)
}

# Integrate all tool commands
mytool(){
    echo -e 'Choose the Function [Number] for tools you want:'
    echo -e '[1] jp - open jupyter lab'
    echo -e '[2] listen - ssh -NL listen remote host'
    echo -e '[3] pathadd - add environment variable to PATH'
    echo -e '[4] condainit - set conda initial and add startup shell to bashrc/zshrc'
    echo -e '[5] sz - view folder and file size'
    echo -e '[6] listen_vpn - listen remote server vpn (Only support Local)'
    echo -e '[7] download_googledrive - download file from google drive'
    echo -e '[8] vpstest - test the vps.'
    echo -e 'input you choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        jp
    elif [ "${func_num}" = 2 ];then
        listen
    elif [ "${func_num}" = 3 ];then
        pathadd
    elif [ "${func_num}" = 4 ];then
        condainit
    elif [ "${func_num}" = 5 ];then
        sz
    elif [ "${func_num}" = 6 ];then
        listen_vpn
    elif [ "${func_num}" = 7 ];then
        download_googledrive
    elif [ "${func_num}" = 8 ];then
        vpstest
    else
        echo -e 'Invalid Input!'
    fi
}
# <<< myool end <<<

# >>> mypip >>>
# Function:
# 1. pipset - modify pip source
# 2. pipbase - pip install some base module
# 3. pipl - pip list and pip show
# 4. pipi - pip install
# 5. pipu - pip uninstall

# modify pip source
pipset(){
    THU_SOURCE=https://pypi.tuna.tsinghua.edu.cn/simple
    ALI_SOURCE=https://mirrors.aliyun.com/pypi/simple/
    TENCENT_SOURCE=http://mirrors.cloud.tencent.com/pypi/simple
    echo -e 'pip source:'
    echo -e '[1] Tsinghua Source'
    echo -e '[2] ALibaba Source'
    echo -e '[3] Tencent Source'
    echo -e 'Input your choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        SOURCE=${THU_SOURCE}
    elif [ "${func_num}" = 2 ];then
        SOURCE=${ALI_SOURCE}
    elif [ "${func_num}" = 3 ];then
        SOURCE=${TENCENT_SOURCE}
    else
        SOURCE=${THU_SOURCE}
        echo -e 'Invalid Input! Using THU default.'

    fi
    echo -e "$ pip config set global.index-url ${SOURCE}"
    pip config set global.index-url ${SOURCE}
}

# pip install some base module
pipbase(){
    unset i
    unset yon
    base_module=('pygments' 'gpustat' 'jupyterlab' 'tensorboard' 'woaigpu' 'gdown' 'shell-gpt')
    for i in ${base_module}; do
        print_text "green" "whether to $ pip install ${i} (y/[n])?" "false"
        read yon
        yon=${yon:-n}
        if [ "${yon}" = "y" ]; then
            pip install ${i}
        fi
    done
    unset i
    unset yon
}

# pip list and pip show
pipl(){
    if [ "${1}" = "" ]; then
        echo '$ pip list'
        pip list
    else
        echo -e "$ pip show ${1}"
        pip show ${1}
    fi
}

# pip install
pipi(){
    if [ "${1}" = "" ]; then
        echo -e 'whether to $ pip install req*.txt? ([y]/n)? \c'
        read yon
        yon=${yon:-y}
        if [ "${yon}" = "y" ];then
            pip install -r req*.txt
        fi
    else
        echo -e "$ pip install $@"
        pip install "$@"
    fi
}

# pip uninstall
pipu(){
    if [ "${1}" = "" ]; then
        pipl
        echo -e 'choose which to uninstall: \c'
        read pkg
        pip uninstall ${pkg} 
    else
       pip uninstall "$@"
    fi
}

# Integrate all tool commands
mypip(){
    echo -e 'Choose the Function [Number] for tools you want:'
    echo -e '[1] pipset - modify pip source'
    echo -e '[2] pipbase - pip install some base module'
    echo -e '[3] pipl - pip list or pip show'
    echo -e '[4] pipi - pip install'
    echo -e '[5] pipu - pip uninstall'
    echo -e 'input you choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        pipset
    elif [ "${func_num}" = 2 ];then
        pipbase
    elif [ "${func_num}" = 3 ];then
        pipl
    elif [ "${func_num}" = 4 ];then
        pipi
    elif [ "${func_num}" = 5 ];then
        pipu
    else
        echo -e 'Invalid Input!'
    fi
}
# <<< mypip end <<<

# >>> myenv >>>
# Funtion:
# 1. env - Activate an environment
# 2. lenv - List installed environments
# 3. cenv - Create new environments
# 4. denv - Delete an installed environment

# conda activate
env() {
    if [ -z "$1" ]; then
        # 获取终端宽度
        terminal_width=$(tput cols)

        # 获取conda环境列表
        conda_env_list=$(conda env list | tail -n +3)

        # 定义颜色和格式
        bold=$(tput bold)
        normal=$(tput sgr0)
        blue=$(tput setaf 4)
        green=$(tput setaf 2)

        # 计算合适的列宽
        env_name_width=$((terminal_width * 25 / 70))
        location_width=$((terminal_width * 35 / 70))

        # 打印表头
        printf "${bold}${blue}%-*s${green}%-*s${normal}%-10s\n" "$env_name_width" "Environment Name" "$location_width" "Location" "Active"
        printf '%*s\n' "$terminal_width" | tr ' ' '='

        # 打印conda环境列表，格式化对齐并添加颜色和激活状态
        echo "$conda_env_list" | awk -v bold="$bold" -v normal="$normal" -v blue="$blue" -v green="$green" \
        -v env_name_width="$env_name_width" -v location_width="$location_width" '
        {
            if ($1 == "*") {
                env_name = $2
                location = $3
                active = "✅"
            } else if ($2 == "*") {
                env_name = $1
                location = $3
                active = "✅"
            } else {
                env_name = $1
                location = $2
                active = "❎"
            }
            printf("%-*s%-*s%-10s\n", env_name_width, env_name, location_width, location, active)
        }' | column -t -s ' ' | while IFS= read -r line; do
            env_name=$(echo "$line" | awk '{print $1}')
            location=$(echo "$line" | awk '{print $2}')
            active=$(echo "$line" | awk '{print $3}')
            printf "${blue}%-*s${green}%-*s${normal}%-10s\n" "$env_name_width" "$env_name" "$location_width" "$location" "$active"
        done

        # 恢复终端颜色
        tput sgr0

        printf '\n'
        # 提取环境名称列表
        condaenvs=$(echo "$conda_env_list" | grep "^\w" | awk '{print $1}')

        # 根据shell类型生成环境数组
        if [[ "$SHELL" == *"zsh" ]]; then
            envs_array=("${(f)condaenvs}")
        elif [[ "$SHELL" == *"bash" ]]; then
            IFS=$'\n' read -r -d '' -a envs_array <<< "$condaenvs"
        else
            echo 'Invalid shell type: ' $SHELL
            return 1
        fi

        PS3='The environment to activate: '
        select env in "${envs_array[@]}" "deactivate"; do
            if [ "$env" = "deactivate" ]; then
                conda deactivate
                break
            elif [ -n "$env" ]; then
                echo "activate environment: $env"
                conda activate "$env"
                break
            fi
        done
        unset PS3
    else
        conda activate "$1"
    fi
}

# list conda envs
alias lenv='conda info -e'

# create conda env
cenv(){
    echo -e 'The name of the environment to create: \c'
    read Env_name
    conda env list
    echo -e 'Copy from existing env (default no copy): \c'
    read Source_Env_name
    if [ "${Source_Env_name}" = "" ];then
        echo -e 'Python version (default 3.7): \c'
        read Py_version
        if [ "${Py_version}" = "" ];then
            echo -e "$ conda create --name ${Env_name} python=3.7 ipykernel -y"
            conda create --name ${Env_name} python=3.7 ipykernel -y
            echo -e "$ python -m ipykernel install --user --name ${Env_name}"
            python -m ipykernel install --user --name ${Env_name}
        else
            echo -e "$ conda create --name ${Env_name} python=${Py_version} ipykernel -y"
            conda create --name ${Env_name} python=${Py_version} ipykernel -y
            echo -e "$ python -m ipykernel install --user --name ${Env_name}"
            python -m ipykernel install --user --name ${Env_name}
        fi
    else
        conda create --name ${Env_name} --clone ${Source_Env_name}
    fi
}

# delete conda env
denv(){
    conda env list
    echo -e 'The name of the environment to delete: \c'
    read Env_name
    echo -e "Do you want to delete the environment: ${Env_name}? ([y]/n)? \c"
    read yon
    if [ "${yon}" = "y" ];then
        echo -e "$ conda remove -n ${Env_name} --all"
        conda remove -n ${Env_name} --all
    else
        echo -e "${Env_name} not deleted."
    fi
}

# Integrate all conda commands
myenv(){
    echo -e 'Choose the Function [Number] for conda you want:'
    echo -e '[1] env - Activate an environment'
    echo -e '[2] lenv - List installed environments'
    echo -e '[3] cenv - Create new environments'
    echo -e '[4] denv - Delete an installed environment'
    echo -e 'input you choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        env
    elif [ "${func_num}" = 2 ];then
        lenv
    elif [ "${func_num}" = 3 ];then
        cenv
    elif [ "${func_num}" = 4 ];then
        denv
    else
        echo -e 'Invalid Input!'
    fi
}
# <<< myenv end <<<

# >>> mygpu >>>
# Function:
# 1. gpu - gpustat realtime
# 2. nvidia - nvidia-smi realtime
# 3. pid - view pids for all gpus
# 4. gpus - CUDA_VISIBLE_DEVICES

# gpu listen
alias gpu='gpustat -i 0.2 -p'
alias nvidia='watch -n 0.2 nvidia-smi'
alias gpus='echo "CUDA_VISIBLE_DEVICES"'

# View pids for all gpus 
pid(){
    echo -e "Use sudo? ([y]/n)? \c"
    read yon
    if [ "${yon}" = "y" ];then
        echo '$ sudo fuser -v /dev/nvidia*'
        sudo fuser -v /dev/nvidia*
    else
        echo '$ fuser -v /dev/nvidia*'
        fuser -v /dev/nvidia*
    fi
}

# Integrate all GPU commands
mygpu(){
    echo -e 'Choose the Function [Number] for GPU you want:'
    echo -e '[1] gpu - gpustat realtime'
    echo -e '[2] nvidia - nvidia-smi realtime'
    echo -e '[3] pid - view pids for all gpus'
    echo -e '[4] gpus - CUDA_VISIBLE_DEVICES'
    echo -e 'input you choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        gpu
    elif [ "${func_num}" = 2 ];then
        nvidia
    elif [ "${func_num}" = 3 ];then
        pid
    elif [ "${func_num}" = 4 ];then
        echo 'CUDA_VISIBLE_DEVICES'
    else
        echo -e 'Invalid Input!'
    fi
}
# <<< GPU end <<<

# >>> mypermission >>>
# Function:
# 1. mychmod - modify directory permissions levels
# 2. mychown - modify directory owners
# 3. passwd - change passwards

# chmod
mychmod(){
    echo -e 'This is a funtion for [chmod] to modify directory permission levels.'
    echo -e 'Input directory: \c'
    read dir
    if [ -d "${dir}" ];then
        echo -e 'Input permission level (e.g. 777): \c'
        read permission
        echo -e "Do you want to change the directory [${dir}] to [${permission}]? ([y]/n)? \c"
        read yon
        if [ "${yon}" = "y" ];then
            echo -e "Use sudo? ([y]/n)? \c"
            read yyon
            if [ "${yyon}" = "y" ];then
                echo -e "$ sudo chmod -R ${permission} ${dir}"
                sudo chmod -R ${permission} ${dir}
            else
                echo -e "$ chmod -R ${permission} ${dir}"
                chmod -R ${permission} ${dir}
            fi
        fi
    else
        echo -e 'Invalid direcctory!'
    fi
}

# chown 
mychown(){
    echo -e 'This is a funtion for [chown] to modify directory owners.'
    echo -e 'Input directory: \c'
    read dir
    if [ -d "${dir}" ];then
        echo -e 'Input new owner (user or user:group): \c'
        read owner
        echo -e "Do you want to change the directory [${dir}] to the owner [${owner}]? ([y]/n)? \c"
        read yon
        if [ "${yon}" = "y" ];then
            echo -e "Use sudo? ([y]/n)? \c"
            read yyon
            if [ "${yyon}" = "y" ];then
                echo -e "$ sudo chown -R ${owner} ${dir}"
                sudo chown -R ${owner} ${dir}
            else
                echo -e "$ chown -R ${owner} ${dir}"
                chown -R ${owner} ${dir}
            fi
        fi
    else
        echo -e 'Invalid direcctory!'
    fi
}

# Integrate all Permission commands
mypermission(){
    echo -e 'Choose the Function [Number] for Permission you want:'
    echo -e '[1] mychmod - modify directory permissions levels'
    echo -e '[2] mychown - modify directory owners'
    echo -e '[3] passwd - change passward'
    echo -e 'input you choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        mychmod
    elif [ "${func_num}" = 2 ];then
        mychown
    elif [ "${func_num}" = 3 ];then
        passwd
    else
        echo -e 'Invalid Input!'
    fi
}
# <<< mypermission end <<<

# >>> mygit >>>
# some git config
alias gita='git add'
alias gitaa='git add .'
alias gitb='git branch'
gitc(){
    echo -e 'Commit content: \c'
    read commit
    git commit -m ${commit}
}
alias gitl='git log'
alias gitr='git reset'
alias gc='git clone'
gitch(){
    if [ "${1}" = "" ]; then
        gitb
        echo -e 'which branch to checkout: \c'
        read branch_name
        git checkout ${branch_name};
	else
		git checkout ${1}
	fi
}
alias gitps='git push origin master'
alias gitpl='git pull'
alias gitst='git status'

# Integrate all Git commands
mygit(){
    echo -e 'Choose the Function [Number] for Git you want:'
    echo -e '[1] gita - git add'
    echo -e '[2] gitaa - git add .'
    echo -e '[3] gitc - git commit'
    echo -e '[4] gitl - git log'
    echo -e '[5] gitr - git reset'
    echo -e '[6] gc - git clone'
    echo -e '[7] gitch - git checkout'
    echo -e '[8] gitps - git push origin master'
    echo -e '[9] gitbpl - git pull'
    echo -e '[10] gitst - git status'
    echo -e '[11] gitb - git branch'
    echo -e 'input you choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        gita
    elif [ "${func_num}" = 2 ];then
        gitaa
    elif [ "${func_num}" = 3 ];then
        gitc
    elif [ "${func_num}" = 4 ];then
        gitl
    elif [ "${func_num}" = 5 ];then
        gitr
    elif [ "${func_num}" = 6 ];then
        gc
    elif [ "${func_num}" = 7 ];then
        gitch
    elif [ "${func_num}" = 8 ];then
        gitps
    elif [ "${func_num}" = 9 ];then
        gitpl
    elif [ "${func_num}" = 10 ];then
        gitst
    elif [ "${func_num}" = 11 ];then
        gitb
    else
        echo -e 'Invalid Input!'
    fi
}
# <<< mygit end <<<

# >>> Others >>>
# update bash/zsh profile
alias sc="source ${shell_file}"
# list directory
if [[ -f ~/.ruby/bin/colorls ]] || [[ -f /usr/local/bin/colorls ]];then
    if [[ -f ~/.ruby/bin/colorls ]];then
        export PATH=~/.ruby/bin:$PATH
    fi
    alias ls='colorls --sd'
    alias la='colorls --sd --all'
    alias ll='colorls --sd --all -l'
    alias tree='colorls --tree'
else
    alias ll='ls -alF'
    alias la='ls -A'
    alias l='ls -CF'
fi

# support joshuto
if command -v joshuto >/dev/null 2>&1; then
    alias l='joshuto'
fi
if [[ -f $HOME/.joshuto/target/release/joshuto ]]; then
    alias l='$HOME/.joshuto/target/release/joshuto'
fi

# clear terminal
alias cl='clear'
# view code with format
alias pcat='pygmentize -g'
# open tensorboard with tb
alias tb='tensorboard --logdir=./'
# download files or folder
download() {
  if [ $# -ge 1 ]; then
    tsz -r "$@"
  else
    PS3='Please select a file or folder to download: '
    select file in *; do
      if [ -n "$file" ]; then
        tsz -r "$file"
        break
      else
        echo "Invalid selection, please make a new selection."
      fi
    done
    unset PS3
  fi
}

# upload folder
upload(){
    echo -e '[1] File / Files'
    echo -e '[2] Folder / Folders'
    echo -e 'Your choose: \c'
    read func_num
    if [ "${func_num}" = 1 ];then
        trz
    elif [ "${func_num}" = 2 ];then
        trz -r
    else
        echo -e 'Invalid Input!'
    fi
}
# open ssh with tssh --dragfile

alias tssh='tssh --dragfile'
alias tsshd='tssh --dragfile'

# VPN commands (only for Linux)
startvpn(){
    echo 'Start VPN in terminal!'
    echo 'Must be install vpn before. If not, run install_vpn for linux.'
    echo -e "socks5 proxy(default: 7891): \c"
    read all_port
    echo -e "http proxy(default: 7890): \c"
    read http_port
    echo -e "https proxy(default: 7890): \c"
    read https_port
    if [ "${all_port}" = "" ];then
        all_port=7891
    fi
    if [ "${http_port}" = "" ];then
        http_port=7890
    fi
    if [ "${https_port}" = "" ];then
        https_port=7890
    fi
    echo -e "$ export ALL_PROXY=socks5://127.0.0.1:${all_port}"
    echo -e "$ export http_proxy=http://127.0.0.1:${http_port}"
    echo -e "$ export https_proxy=http://127.0.0.1:${https_port}"
    export ALL_PROXY=socks5://127.0.0.1:${all_port}
    export http_proxy=http://127.0.0.1:${http_port}
    export https_proxy=http://127.0.0.1:${https_port}
    echo 'You can see status by $ curl cip.cc / $ curl -x $ALL_PROXY cip.cc'

}
alias stopvpn='echo \
"Stop VPN in terminal!
You can see status by $ curl cip.cc" \
&& unset ALL_PROXY && unset http_proxy && unset https_proxy'

# a uniform function to view files with different formats
uview(){
    if [ "${1}" = "" ]; then
        echo -e 'File Name: \c'
        read filename
	else
		filename=${1}
	fi

    if [ -f ${filename} ];then
        case "${filename}" in
            *.bam ) samtools view ${filename} | less -S;;
            * ) echo "Not support this format. Supported formats: [.bam]";;
        esac
    else
        echo "${filename} not exist."
    fi
}

# add to docker group
dockeradd(){
    print_text "green" "This is a funtion to add user to docker group." "false"
    printf "\n"
    print_text "green" "Input the user to add (default: $(whoami)):" "false"
    read user
    user=${user:-$(whoami)}
    sudo gpasswd -a $user docker     #将登陆用户加入到docker用户组中
    newgrp docker     #更新用户组
}

# <<< Others end <<<
